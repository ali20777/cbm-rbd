\documentclass[authoryear]{elsarticle}

% ------------ packages -------------

\usepackage[utf8]{inputenc}
\usepackage[OT1]{fontenc}
\usepackage{graphicx}
\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}

\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{booktabs}
\usepackage{tikz}

\usepackage{url}
\usepackage[bookmarks]{hyperref}

%\usetikzlibrary{shapes.misc,fit}
\usetikzlibrary{%
   arrows,%
   calc,%
   fit,%
   patterns,%
   plotmarks,%
   shapes.geometric,%
   shapes.misc,%
   shapes.symbols,%
   shapes.arrows,%
   shapes.callouts,%
   shapes.multipart,%
   shapes.gates.logic.US,%
   shapes.gates.logic.IEC,%
   er,%
   automata,%
   backgrounds,%
   chains,%
   topaths,%
   trees,%
   petri,%
   mindmap,%
   matrix,%
   calendar,%
   folding,%
   fadings,%
   through,%
   patterns,%
   positioning,%
   scopes,%
   decorations.fractals,%
   decorations.shapes,%
   decorations.text,%
   decorations.pathmorphing,%
   decorations.pathreplacing,%
   decorations.footprints,%
   decorations.markings,%
   shadows}

%\usepackage{hyperref}
%\usepackage[bookmarks]{hyperref}
%\usepackage[colorlinks=true,citecolor=red,linkcolor=black]{hyperref}

% ------------ custom defs -------------

\newcommand{\reals}{\mathbb{R}}
\newcommand{\posreals}{\reals_{>0}}
\newcommand{\posrealszero}{\reals_{\ge 0}}
\newcommand{\naturals}{\mathbb{N}}

\newcommand{\dd}{\,\mathrm{d}}

\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\renewcommand{\vec}[1]{{\bm#1}}

\newcommand{\uz}{^{(0)}} % upper zero
\newcommand{\un}{^{(n)}} % upper n
\newcommand{\ui}{^{(i)}} % upper i

\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\ol}[1]{\overline{#1}}

\newcommand{\Tsys}{T_\text{sys}}

\newcommand{\Rsys}{R_\text{sys}}
\newcommand{\lRsys}{\ul{R}_\text{sys}}
\newcommand{\uRsys}{\ol{R}_\text{sys}}

\newcommand{\fsys}{f_\text{sys}}
\newcommand{\Fsys}{F_\text{sys}}
\newcommand{\lFsys}{\ul{F}_\text{sys}}
\newcommand{\uFsys}{\ol{F}_\text{sys}}

\newcommand{\lgt}{\ul{g}}
\newcommand{\ugt}{\ol{g}}

\newcommand{\E}{\operatorname{E}}
\newcommand{\V}{\operatorname{Var}}
\newcommand{\wei}{\operatorname{Wei}} % Weibull Distribution
\newcommand{\ig}{\operatorname{IG}}   % Inverse Gamma Distribution

\newcommand{\El}{\ul{\operatorname{E}}}
\newcommand{\Eu}{\ol{\operatorname{E}}}

\def\yz{y\uz}
\def\yn{y\un}
%\def\yi{y\ui}
\newcommand{\yfun}[1]{y^{({#1})}}
\newcommand{\yfunl}[1]{\ul{y}^{({#1})}}
\newcommand{\yfunu}[1]{\ol{y}^{({#1})}}

\def\ykz{y\uz_k}
\def\ykn{y\un_k}

\def\yzl{\ul{y}\uz}
\def\yzu{\ol{y}\uz}
\def\ynl{\ul{y}\un}
\def\ynu{\ol{y}\un}
\def\yil{\ul{y}\ui}
\def\yiu{\ol{y}\ui}

\def\ykzl{\ul{y}\uz_k}
\def\ykzu{\ol{y}\uz_k}
\def\yknl{\ul{y}\un_k}
\def\yknu{\ol{y}\un_k}

\newcommand{\ykzfun}[1]{y\uz_{#1}}
\newcommand{\ykzlfun}[1]{\ul{y}\uz_{#1}}
\newcommand{\ykzufun}[1]{\ol{y}\uz_{#1}}

\def\nz{n\uz}
\def\nn{n\un}
%\def\ni{n\ui}
\newcommand{\nfun}[1]{n^{({#1})}}
\newcommand{\nfunl}[1]{\ul{n}^{({#1})}}
\newcommand{\nfunu}[1]{\ol{n}^{({#1})}}

\def\nkz{n\uz_k}
\def\nkn{n\un_k}
\newcommand{\nkzfun}[1]{n\uz_{#1}}
\newcommand{\nkzlfun}[1]{\ul{n}\uz_{#1}}
\newcommand{\nkzufun}[1]{\ol{n}\uz_{#1}}

\def\nzl{\ul{n}\uz}
\def\nzu{\ol{n}\uz}
\def\nnl{\ul{n}\un}
\def\nnu{\ol{n}\un}
\def\nil{\ul{n}\ui}
\def\niu{\ol{n}\ui}

\def\nkzl{\ul{n}\uz_k}
\def\nkzu{\ol{n}\uz_k}
\def\nknl{\ul{n}\un_k}
\def\nknu{\ol{n}\un_k}


\def\taut{\tau(\vec{t})}
\def\ttau{\tilde{\tau}}
\def\ttaut{\ttau(\vec{t})}

\def\MZ{\mathcal{M}\uz}
\def\MN{\mathcal{M}\un}

\def\MkZ{\mathcal{M}\uz_k}
\def\MkN{\mathcal{M}\un_k}

\def\PkZ{\Pi\uz_k}
\def\PkN{\Pi\un_k}
\newcommand{\PZi}[1]{\Pi\uz_{#1}}

\def\tnow{t_\text{now}}
\def\tpnow{t^+_\text{now}}


% ------------ options -------------

\allowdisplaybreaks

\journal{RESS}

\begin{document}

% ------------ frontmatter -------------

\begin{frontmatter}
\title{Condition-Based Maintenance for Complex Systems\\ based on Current Component Status\\ and Bayesian Updating of Component Reliability}

\author[tue]{Gero Walter}
\ead{g.m.walter@tue.nl}
\author[tue]{Simme Douwe Flapper}
\ead{s.d.p.flapper@tue.nl}

\address[tue]{School of Industrial Engineering, Eindhoven University of Technology, Eindhoven, Netherlands}


\begin{abstract}
We propose a new way of developing a condition-based maintenance policy for complex systems,
based not on a one-dimensional continuous degradation signal,
but on the status of all components within a system.

By means of the survival signature,
a generalization of the system signature allowing for multiple component types,
we obtain a predictive distribution for system survival time
(also known as RUL, remaining useful life)
based on which of the system's components currently function or not,
and the current age of the functioning components.

Component time to failure is modeled by a Weibull distribution with fixed shape parameter.
The scale parameter is iteratively updated in a Bayesian fashion
using the current (censored and non-censored) component lifetimes.
Each component type has a separate model that may also include test data.

The cost-optimal moment of repair for the system is obtained by minimizing the one-cycle unit cost rate.
The unit cost rate is recalculated at fixed time points,
leading to a dynamic policy since the aging of components and possible failures will change the cost-optimal moment of repair.
\end{abstract}

\begin{keyword}
condition-based maintenance \sep system reliability \sep remaining useful life \sep survival signature \sep one-cycle unit cost rate\end{keyword}
\end{frontmatter}


% ------------ manuscript -------------

\section{Introduction}
\label{intro}


***main message:
can do CBM for systems without degradation signal,
especially useful for redundant systems,
dynamic policy using one-cycle unit cost rate (exact, unlike renewal theorem based!),
using iterative Bayesian update of component models,
thus taking all information into account (history and current status)

***Bayesian approach allows component models to include expert info, test data (if available),
and information that can be gained from the behaviour of components in the running system
in the form of censored and non-censored component lifetimes 

***we argue that our approach is CBM because it takes current system state into account
and adjusts the moment of maintenance accordingly.

\subsection*{---------------------}
***general discussion on CBM as usual

***Condition-based maintenance (CBM) has received considerable attention in the literature.
The central idea is to maintain technical systems or components at just the right time,
that is, before they fail,
but not too early, in order to keep reliability high and operating costs low.
%most fully use the component's or system's lifetime and to save on maintenance work

***trade-off between risk of failure during operation
(can lead to costly downtime: idle workforce, missed production, penalties, loss of reputation)
and costs of premature maintenance
(wasting potential component / system lifetime, downtime cost, cost of maintenance work)

***so CBM must be based on some information about the state or health of the component / system.
Two ways: continuous monitoring CBM and inspection-based CBM.

***Continuous monitoring CBM policies are usually derived
using a directly observable continuously measurable condition / degradation signal,
or constructs such a signal or health status using indirect measurements.
Estimated time till failure (RUL) \citep{2014:rul-review, 2011:rul-review-statistical}
via distance of current signal level to a fixed known failure threshold.

***Inspection-based CBM via delay time model, modeling the time between detectable degradation and failure,
again time till failure via distance of current degradation level to fixed known failure threshold.

***In both cases, maintenance decision via control limit / threshold for the signal
(RUL not explicitely calculated)
by minimizing the expected unit cost rate,
which is often approximated using the renewal reward theorem.
%but in practice threshold often not known

\subsection*{---------------------}

Here we propose a different approach to CBM
for the case when no degradation signal for the system is available,
but system components can be identified and their functioning status
(working or not working) can be monitored.
In this situation, one can use the system's layout in reliability terms
(i.e., its reliability block diagram) and information on components' status
to directly calculate the RUL distribution,
and base the maintenance policy on this distribution.
(In fact, our approach can be seen as CBM based on a multivariate degradation signal,
where each component sends a binary signal, and the reliability block diagram is used
for sensor fusion.)

Our approach can also be seen as a generalization of policies for $k$ out of $N$ systems to arbitrary system layouts.
Furthermore, our approach allows for multiple types of components in the system,
with each component type having its own failure behaviour.

%We use a parametric model not for a degradation signal of the system or for the delay time, but for component lifetimes:
For each component type, we use the well-known Weibull distribution to model component lifetimes.
To keep the model simple and to demonstrate its feasability, we assume the shape parameter for each component type to be known,
focusing on learning of the scale parameter,
and that components fail independently.
These simplifying assumptions will often not hold in practice,
then the model can serve as a first approximation.
Generally, we see our contribution as opening up an entirely new way to derive CBM policies,
and thus consider the model in this paper more as a proof of concept,
where extension to more realistic models must happen in a second step.
As an example, it is possible to extend the model to learn also the shape parameter along the lines of
\cite{1969:soland},
but this is not included here as it would complicate presentation.
%need only to observe when a component fails,
%and expert information about expected component failure times.

The Bayesian approach to the Weibull model \citep[see, e.g.,][]{1996:mazzuchi-soyer} allows to integrate, for each component type,
three sources of information: expert knowledge, data from component tests,
and the status of components in the monitored system. %, i.e., current system condition.
These information sources are integrated into a single component model
using the iterative nature of Bayesian updating,
leading to a so-called posterior predictive distribution for the number of components surviving at any time in the future.

These predictive distributions are then used to calculate the exact distribution of system RUL
using the survival signature \citep{2012:survsign}.
(***we therefore accomplish the same as \cite{2013:si-et-al} for their situation.)

By its Bayesian nature, the system RUL distribution adequately reflects the uncertainties in RUL estimation
related to modeling and prediction \citep{2015:sankararaman},
readily adapting to any changes in component behaviour.
The use of conjugate priors means that we get explicit formulas for the RUL distribution,
so no numerical integration or simulation techniques are necessary.
This allows for a very frequent, or even real-time, update of the RUL distribution,
taking into account the changed structure when components have failed
and the information gain from updating the component reliability distributions.

Based on the RUL distribution at any current time $\tnow$,
the optimal moment of maintenance given all information available at $\tnow$
is then determined by minimizing the expected one-cycle unit cost rate.
The expected one-cycle unit cost rate, also known as one-cycle criterion
\citep{1984:ansell-bendell-humble,1996:mazzuchi-soyer,2006:coolen-schrijner-coolen},
makes the trade-off between preventive and corrective maintenance according to the current cycle only,
unlike the usually employed renewal based criterion,
which approximates the unit cost rate using a renewal argument \citep[p.~296]{1996:mazzuchi-soyer},
but is not suited for situations where one may whish to change the strategy per cycle \citep{2006:coolen-schrijner-coolen}.

Since the RUL distribution changes with current time $\tnow$,
the corresponding optimal moment of maintenance $\tau^*$ changes as well,
leading to a dynamic adaptive maintenance policy,
similar to a CBM policy based on a continuosly monitored degradation signal.
However, unlike such threshold-based CBM policies,
our approach allows to easily take into account the time needed to set up maintenance work (known as set-up time),
since it gives the optimal moment of maintenance as a time beyond current time $\tnow$,
and maintenance can be initiated as soon as $\tau^*$ approaches the set-up time.

In this paper, we assume that at the moment of maintenance,
all components in the system are replaced,
so the cost parameters in the unit cost rate must be determined accordingly.
One could instead consider other replacement schemes (e.g., replacing only the failed components),
or indeed optimize the unit cost rate over all possible replacement schemes,
since our method for RUL calculation can handle differently aged components. 
However, optimizing over replacement schemes opens up a full research programme on its own,
and for situations with high set-up costs,
as is typical for CBM applications,
the replace-all scheme is most likely the cost-optimal strategy. 


***figure of process: component priors $\to$ component posteriors $\to$ system RUL $\to$ $g(\tau)$ $\to$ $\tau^*$


***Expert input in our model is, for each component type,
Weibull shape parameter, expected failure time (translated to scale parameter),
and expert info weight (how sure about mean failure time guess).
Component test data (can include right-censored observations) is optional.
Further input is system layout (reliability block diagram indicating which component belongs to which type)
and the cost parameters $c_p$ and $c_u$.

***here all expressed in time, but could also be in usage (number of cycles, etc).

***compare to $M^*$ out of $N$ policy:
we are dynamic (would mean for a $M^*$ out of $N$ policy that $M^*$ decreases over time due to component aging),
we learn about component lifetimes,
and we allow for set-up time



\section{Literature***}

Example for Bayesian method in CBM via inspections: \cite{2007:wang-jia}
propose a model that uses Bayesian updating,
but the model aims to identify an optimal inspection interval.
%This is CBM via inspections, not CBM via continuous monitoring as we aim to do.

\begin{scriptsize}
Wang \& Jia (2007) have a model for defects arrival (homogeneous Poisson process with rate $\lambda$, so no aging),
model for delay time (time between defect and failure) is Weibull $h \sim \wei(\alpha,\beta)$,
and each of $\lambda, \alpha, \beta$ has a Gamma prior distribution.
The expected overall cost rate is then used to find a cost-optimal inspection interval.
For this they assume that failures are immediately repaired,
and defects found in an inspection are repaired during inspection.

They use prior predictive distributions for certain statistics (number of defects, number of failures, \ldots between $0$ and $T$)
to obtain prior values for the Gamma hyperparameters,
by solving prior predictive equations -- but give no detail on how they actually do this.

In the end they actually do not advocate to calculate the posterior expected cost rate (15),
but rather plug in posterior estimates for $\lambda, \alpha, \beta$,
so neglecting uncertainty in estimation.
(We do not assume a parametric distribution for delay time,
it rather arises as a consequence of the system layout and component failure distributions.)

\end{scriptsize}

Example for Bayesian method in CBM with continuous monitoring: \cite{2011:elwany-et-al}
(exponential degradation model, whose parameters $\theta'$ and $\beta$ each have a prior
which is updated using the degradation signal history,
and use total expected infinite-horizon discounted cost to determine the maintenance policy,
RUL not explicitely calculated)

Example for Bayesian method in prediction of system remaining useful life: \cite{2012:sun-et-al}
(constructs health index for a system based on sensor measurements,
health status prediction is updated sequentially,
leads to RUL distribution like our method,
but no link from RUL to maintenance decision)

\cite{2013:si-et-al} do CBM with continuous monitoring for a single component,
taking into account the whole degradation path history.
The authors provide exact expressions for the RUL distribution, which is updated in an empirical Bayesian framework using conjugate priors.
The RUL distribution is used to construct a replacement decision model using the unit cost rate via renewal reward
(eq. 35)\\
***this is most similar to what we do: exact RUL distribution $\to$ maintenance decision,
but we have component status instead of degradation signal as basis for RUL,
and we model epistemic uncertainties!\\

\cite{2011:kim-et-al} develop a periodic monitoring CBM policy
where a maintenance decision is triggered when
a Bayesian control chart (a sequentially updated health indicator) %posterior probability that system is in a 'warning' state
exceeds a control limit (threshold) that is determined
by minimizing the expected average cost per time unit.
(We use the same cost criterion, but base the maintenance decision directly on our exact RUL estimation.)

***typical recent example for Bayesian network models in maintenance -- could also cover system reliabilty terrain***
maybe Jones et al (RESS 95:3, 2010) ``The use of Bayesian network modelling for maintenance planning in a manufacturing industry'',
or Bouaziz et al (2013) ``Towards Bayesian network methodology for predicting equipment health factor of complex semiconductor systems''

\begin{scriptsize}
Bayesian networks (BNs) are a very general method to jointly model multiple dependent random variables in a Bayesian way. 
This needs assessments of conditional independece relations, and conditional probability models for each variable,
the latter often in form of conditional probability tables (discrete variables).
A Bayesian network models probabilistic relations between variables,
unlike a reliability block diagram, which gives a deterministic relation
between the status of components and the system state.

One could model a system as a BN (each component is a variable),
but that would add a lot of complications.
Most algorithms for BNs assume discrete distributions,
and do not scale well to large networks (many tasks are NP-hard).

The above papers seem to use a BN to model a degradation signal or (system) health index (have to check again to be sure).
Our approach is different, as we get an exact formulation for the system RUL directly.

\end{scriptsize}


\section{***summary of ASCE-ASME paper method}

sets of priors on component survival,
survival signature,
test data inclusion
(write down explicit formula for test data including censored observations),
noninformatiove censoring,
set of system reliability curves as output,
wider set in case of prior-data conflict


\section{***extensions to ASCE-ASME paper method}
\label{sec:extensions}

when repaired/replaced components are present in system,
then one needs to use actual ages (and not time since system startup) in parameter update,
introduces new component type for $\Rsys(t)$ calculation but with same posterior parameters as unreplaced component type

repaired/replaced components require the creation of a separate type in the survival signature decomposition
and thus the calculation of separate posterior predictive probabilities
$P(C^k_t = l_k \mid \nkz,\ykz,\text{test data},\text{monitoring data})$,
which use, however, the same hyperparameter learning (using actual component ages) as the `parent type'.

output is a set of current system reliability curves
taking into account the current system state,
including the current ages of system components, 
and the lifetime histories of all component types,
including test data and expert assessments.
The set of current, updated system reliability curves gives a RUL estimate
in the form of a p-box, thus reflecting both aleatoric and epistemic uncertainty in the estimate.


\section{***from (set of) reliability curves to maintenance decision}

To find the optimal moment for maintenance based on the current set of system reliability curves,
we minimize the expected average cost per time unit,
or unit cost rate, $g(\tau)$ %, where $\tau$ is the moment when preventive maintenance is exectued.
(could be discounted as well, out of scope here.)

In the literature, commonly two ways to calculate the unit cost rate are considered,
a renewal reward theory based long-term unit cost rate $g_r(\tau)$,
and the one-cycle cost rate $g_1(\tau)$ \citep{1996:mazzuchi-soyer}.
We will discuss both approaches here with their advantages and disadvanatges.

Let $c_p$ be the cost of planned / preventive maintenance, and $c_u$ the cost of unplanned / breakdown maintenance, where $c_p < c_u$.

\subsection{***unit cost rate via renewal reward}

The renewal reward theory based approach considers the unit cost rate as a long-term average,
where the proposed policy is used over a large number of replacement cycles,
and cycles can be seen as stochastic copies of each other.
Under this assumption, the unit cost rate is, according to renewal theory,
given as the expected cycle cost $ECC(\tau)$ divided by the expected cycle length $ECL(\tau)$:
\begin{align}
g_r(\tau) &= \frac{ECC(\tau)}{ECL(\tau)} = \frac{c_p \Rsys(\tau) + c_u \big(1-\Rsys(\tau)\big)}{\tau \Rsys(\tau) + \int_0^\tau \Rsys(t) \dd t}\,,
\end{align}
and $\tau_r^* = \arg\min g_r(\tau) - \tnow$ is the cost-optimal repair time from now
(since $\Rsys(\cdot)$ is always in terms of time since system startup)

***most often used in literature \citep{2013:si-et-al}, \citep{2011:kim-et-al}

***stochastic copies assumption implies that the system is in the same state at the start of each cycle,
so $c_p$ needs to include the costs of replacing all components
to bring the system into the same state as at startup time.

\subsection{***one-cycle unit cost rate}

The one-cycle unit cost rate approach considers only the costs with respect to the current cycle.
Conditional on the (random) system failure time $\Tsys$, the unit cost rate is 
\begin{align*}
g_1(\tau \mid \Tsys) &=
\begin{cases}
c_p / \tau  & \text{if } \Tsys \ge \tau \\
c_u / \Tsys & \text{if } \Tsys < \tau
\end{cases}
\end{align*}

Taking the expectation over $\Tsys$ leads to the unit cost rate being
\begin{align*}
g_1(\tau) &= \E[g_1(\tau \mid \Tsys)] = \frac{c_p}{\tau} \Rsys(\tau) + c_u \int_0^\tau \frac{1}{t} \fsys(t) \dd t
\end{align*}
***here, $\Rsys(\cdot)$ shifted such that $\tnow = 0$.

Due to our extensions from Section~\ref{sec:extensions},
maintenance work can consist of replacing (or returning to an as-good-as-new state) some or all failed or non-failed components,
as arbitrary component ages can be taken into account.
(However, computation times decrease when all components of the same type are replaced at the same time,
as then the duplication of component types for the survival signature decomposition is not necessary.)


\subsection{***bounds for unit cost rate}

Bounds for $\Rsys(t)$ lead to bounds for $g(\tau)$.
%For each $\tau$, fix $\Rsys(\tau) \in [\lRsys(\tau), \uRsys(\tau)]$ and optimize $I(\tau) = \int_0^\tau \Rsys(t) \dd t$
%nonparametrically: $\ol{I}(\tau)$ by $\uRsys(t)$, $\ul{I}(\tau)$ by $\lRsys(t)$ until level of $\Rsys(\tau)$.
Can get bounds $\lgt(\tau)$ and $\ugt(\tau)$ in the same way as bounds $\lRsys(t)$ and $\uRsys(t)$ in ASCE-ASME paper:
need to optimize only over
$\nkzfun{1} \in \left[\nkzlfun{1}, \nkzufun{1}\right], \ldots, \nkzfun{K} \in \left[\nkzlfun{K}, \nkzufun{K}\right]$.

This works because, like $\Rsys(t)$, also $g(\tau)$ is monotone in $\ykzfun{1}, \ldots \ykzfun{K}$:
$\Rsys(\tau)$ is monotone in $\ykzfun{1}, \ldots \ykzfun{K}$ (ASCE-ASME paper),
and $g(\tau)$ is monotonely decreasing in $\Rsys(\tau)$:

First look at $I(\tau) := \int_0^\tau \Rsys(t) \dd t$.
A lower bound for $I(\tau)$ is $\tau \Rsys(\tau)$ (obtained when $\Rsys(t)$ drops to $\Rsys(\tau)$ immediately after $t=0$),
and an upper bound for $I(\tau)$ is $\tau$ (obtained when $\Rsys(t)$ remains at $1$ until immediately prior to $t = \tau$).
Therefore, for each $\tau$ and $\Rsys(\tau)$ there exists a constant $R^* \in [\Rsys(\tau), 1]$
such that $I(\tau) = \tau R^*$.
Note that $R^*$ increases when $\Rsys(\tau)$ increases.

Setting $\Rsys(\tau) =: R$ and $g(\tau) =: g$ to simplify notation, we get
\begin{align*}
g &= \frac{c_p R + c_u (1-R)}{\tau R + \tau R^*}
   = \frac{(c_p - c_u) R + c_u}{\tau R + \tau R^*}\,.
\end{align*}
As $(c_p -c_u) < 0$, the enumerator of $g$ is monotonely decreasing in $R$.
The denominator of $g$ is monotonely increasing in $R$, since $R^*$ must increase when $R$ increases.
In total, $g$ is thus monotonely decreasing in $R$.

***formulate above as theorem?


\subsection{***from bounds for $g(\tau)$ to (set of) $\tau^*$:}

%worst case, best case, interval (how?)
\begin{itemize}
\item worst case (minimax strategy): minimizing $\ugt(\tau)$ leads to $\tau^*_u$.
\item interval dominance: for each $\tau$, we get a $g(\tau)$ interval $[\lgt(\tau), \ugt(\tau)]$.
Throw out all $\tau$'s for which $\lgt(\tau) \ge \ugt(\tau^*_u)$.
This will leave us with the set of $\tau$'s that are not dominated by $\tau^*_u$.
(The set will be quite wide probably.)
\item parametric / maximality (?): collect all $\tau$'s for which there is a prior parameter combination such that $\tau$ minimizes $g(\tau)$.
(Need to do grid search over $\nkz$'s, or keep optimal pars when calculating $\lgt(\tau)$.)
\end{itemize}

\subsection{***simple 95\% policy}

Or, alternatively to all the above, simple 95\% policy?
Repair time from now such that lower system reliability is at least 95\%, i.e., upper system failure probability is at most 5\%.


\section{Case study / numerical example}

which system layout? something that demonstrates the power of the method (complex layout) or something simple?

complex: e.g., bridge system where each of the four elements is a two out of three, and the bridge element is a two-parallel.

or the simplified brake system from ASCE-ASME paper?


\section{Outlook}

*** to use the model for inspection-based CBM (if no repair necessary, find optimal timing of next inspection),
we would need to add interval-censored data (failure has happened between last and current inspection)



\section*{Acknowledgements}

CAMPI

Frank Coolen for inspiring discussions

\section*{Bibliography}

\bibliographystyle{elsarticle-harv}

\bibliography{refs}

\end{document}
